module statics/record

imports statics/base
imports statics/variable
imports statics/type
imports signatures/record-sig

signature  
  constructors 
    REC  : scope -> TYPE
    NULL : TYPE
    
rules

  subtype(_, NULL(), REC(_)).
  
  equitype(NULL(), REC(_)).
  equitype(REC(_), NULL()).
  
  lub(T@REC(_), NULL()) = T.
  lub(NULL(), T@REC(_)) = T.
  
rules // record type
  
  typeOfType(s, t@RecT(fdecls)) = REC(s_rec) :-
    new s_rec,
    fdeclsOk(s_rec, s, fdecls),
    @t.type := REC(s_rec).

  declOk(s, Record(x, fdecls)) :- {s_rec}
    new s_rec,
    fdeclsOk(s_rec, s, fdecls),
    declareType(s, x, REC(s_rec)).
  
  fdeclOk : scope * scope * FDecl
  fdeclsOk maps fdeclOk(*, *, list(*))
  
  fdeclOk(s_bnd, s_ctx, FDecl(x, t)) :- {T}
    typeOfType(s_ctx, t) == T,
    declareVar(s_bnd, x, T).
    
rules // record construction
  
  typeOfExp(s, e@New(x, fbinds)) = REC(s_rec) :- {p d}
    typeOfTypeRef(s, x) == REC(s_rec),
    fbindsOk(s, REC(s_rec), fbinds).
    
  typeOfExp(s, Cns(x, fbinds)) = typeOfExp(s, New(x, fbinds)).
    
  fbindOk : scope * TYPE * FBind
  fbindsOk maps fbindOk(*, *, list(*))
  
  fbindOk(s, T_rec, FBind(x, e)) :- {T1 T2}
    typeOfExp(s, e) == T1,
    proj(T_rec, x) == T2,
    subtype(e, T1, T2).
    
rules // record projection

  typeOfExp(s, Proj(e, x)) = proj(typeOfExp(s, e), x).
    
  proj(REC(s_rec), x) = typeOfVar(s_rec, x).
    
rules // with record value

  typeOfExp(s, With(e1, e2)) = T :- {s_with s_rec}
    typeOfExp(s, e1) == REC(s_rec),
    new s_with, 
    s_with -P-> s, 
    s_with -R-> s_rec,
    typeOfExp(s_with, e2) == T. 
    
rules // Null
    
  typeOfExp(s, Null()) = NULL().
  
rules

  allFields : scope -> list((path * (occurrence * TYPE)))
  
  allFields(s) = ds :-
    query typeOfDecl
      filter e and { Var{ y @_ } :- y == _ }
          min $ < I, $ < P, I < P, R < P and { _, _ :- true }
          in s |-> ds.

//  subtype(e, REC(s1), REC(s2)) :- {ps}
//    allFields(s2) == ps,
//    fieldsInScope(e, ps, s1).
//    
//  fieldInScope : Exp * (path * (occurrence * TYPE)) * scope 
//  fieldsInScope maps fieldInScope(*, list(*), *) 
//
//  fieldInScope(e, (_, (Var{x}, T)), s) :- {S}
//    lookupVar(s, x) == S | error $[field [x] not in subtype],
//    subtype(e, S, T).