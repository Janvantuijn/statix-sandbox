module statics/module-seq
//
//imports statics/base
//imports statics/variable
//imports statics/numbers
//imports signatures/module-seq-sig 
//
//signature
//  sorts DecGroups
//  constructors
//    MOD : scope -> TYPE
//     
//rules 
//
//  declOk(s, Module(m, decls)) :- {s_mod s_end}
//    new s_mod, s_mod -P-> s,
//    declareMod(s, m, MOD(s_end)),
//    decGroupsOk(s_mod, decls) == s_end.
//   
//  decGroupsOk : scope * Decls -> scope
//  
//  decGroupsOk(s, Decs(decls)) = s:- 
//    declsOk(s, decls).
//    
//  decGroupsOk(s1, Seq(decls1, decls2)) = s_end :- {s2}
//    new s2, s2 -P-> s1,
//    declsOk(s1, decls1),
//    decGroupsOk(s2, decls2) == s_end.
// 
//  declOk(s, Import(p)) :- {s_mod s_end} 
//    typeOfPathRef(s, p) == MOD(s_mod),
//    s -I-> s_mod.
//    
//    
////  declOk(s, ExtendRemote(p, e)) :- false.
// 
//// permission to extend
////  declOk(s, Import(p)) :- {s_mod s_end} 
////    typeOfModRef(s, p) == MOD(s_mod),
////    s -I-> s_mod,
////    declareVar(s_mod, "x", INT()).
//    
//  
//           
//rules // module reference
//        
//  typeOfExp(s, ModRef(p, x)) = T :- {s_mod}
//    typeOfPathRef(s, p) == MOD(s_mod),
//    typeOfVar(s_mod, x) == T. 
//    
//  proj(MOD(s_mod), x) = T :- {p d}
//    typeOfVar(s_mod, x) == T.
//  
//rules
//
//  typeOfPathImp : scope * Path -> TYPE 
//  typeOfPathRef : scope * Path -> TYPE 
//  
//  resolvePathImp(s, Path([x | xs])) = s_end :- {s_mod} 
//    typeOfModPar(s, x) == MOD(s_mod),
//    resolvePathList(s_mod, xs) == s_end.
//  
//  typeOfPathRef(s, Path([x | xs])) = s_end :- {s_mod} 
//    typeOfModRef(s, x) == MOD(s_mod),
//    resolvePathList(s_mod, xs) == s_end.
//    
//  resolvePathList : scope * list(ID) -> scope
//  
//  resolvePathList(s, []) = s.
//  
//  resolvePathList(s, [x | xs]) = s_end :- {s_mod}
//    typeOfModMember(s, x) == MOD(s_mod),
//    resolvePathList(s_mod, xs) == s_end. 
//  
//signature
//  namespaces
//    Mod  : string 
//  name-resolution
//    resolve Mod 
//      filter P P* I*
//      min $ < I, $ < P, I < P, R < P 
//           
//rules // module binding 
//
//  declareMod      : scope * string * TYPE
//  declareModRaw   : scope * string * TYPE
//  typeOfModRef    : scope * string -> TYPE
//  typeOfModPar    : scope * string -> TYPE
//  typeOfModMember : scope * string -> TYPE
//  
//  declareMod(s, x, T) :-   
//    s -> Mod{x} with typeOfDecl T,   
//    query typeOfDecl
//      filter P*  and { Mod{ y @_ } :- y == x }
//          min $ < I, $ < P, I < P, R < P and { _, _ :- true }
//          in s |-> [(_, (Mod{ x }, T))] 
//          | error $[Duplicate definition of module [x]].
//       
//  typeOfModRef(s, x) = T :- {x'}
//    typeOfDecl of Mod{x} in s |-> [(_, (Mod{x'}, T))|_] 
//             | error $[Module [x] not defined],
//               // permissive lookup to cope with double declaration 
//    @x.ref := x'.
//
////  typeOfModRef(s, x) = T :- {x'}
////    query typeOfDecl
////      filter P P* I* and { Mod{ y @_ } :- y == x }
////          min $ < I, $ < P, I < P, R < P and { _, _ :- true }
////          in s |-> [(_, (Mod{ x' }, T))|_] 
////      | error $[Module [x] not defined],
////    @x.ref := x'.
//    
//  typeOfModPar(s, x) = T :- {x'}
//    query typeOfDecl
//      filter P P* I* and { Mod{ y @_ } :- y == x }
//          min $ < I, $ < P, I < P, R < P and { _, _ :- true }
//          in s |-> [(_, (Mod{ x' }, T))|_] 
//      | error $[Module [x] not defined],
//    @x.ref := x'.
//    
//  typeOfModMember(s, x) = T :- {x'}
//    query typeOfDecl
//      filter e and { Mod{ y @_ } :- y == x }
//          min $ < I, $ < P, I < P, R < P and { _, _ :- true }
//          in s |-> [(_, (Mod{ x' }, T))|_] 
//      | error $[Module [x] not defined],
//    @x.ref := x'.
//          
//         
////  lookupMod       : scope * string -> TYPE
////  lookupMod(s, x) = T :- {x'}
////    typeOfDecl of Mod{x} in s |-> [(_, (Mod{x'}, T))|_] 
////             | error $[Module [x] not defined], 
////               // permissive lookup to cope with double declaration 
////    @x.ref := x'.
