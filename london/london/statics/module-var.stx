module statics/module-var

imports statics/base
imports statics/variable
imports statics/numbers
imports statics/type
imports signatures/module-var-sig 

signature
  constructors
    MOD : scope -> TYPE
     
rules // module definitions

  declOk(s, Module(m, ms)) :- {s_mod s_end}
    new s_mod, s_mod -P-> s, 
    declareMod(s, m, MOD(s_end)),
    membersOk(s_mod, ms) == s_end.
   
  membersOk : scope * Members -> scope
  
  membersOk(s, Members(decls)) = s:- 
    declsOk(s, decls).
    
  membersOk(s1, Seq(ms1, ms2)) = s_end :- {s2}
    membersOk(s1, ms1) == _,
    new s2, s2 -P-> s1, 
    membersOk(s2, ms2) == s_end.
 
rules // imports 

  declOk(s, Import(p)):- {s_mod}
    typeOfPath(scopeOfParent(s), p) == MOD(s_mod),
    s -I-> s_mod.
 
  typeOfPath : scope * Path -> TYPE
  
  typeOfPath(s, PVar(m)) = typeOfRef(s, m).
  
  typeOfPath(s, Path(p, m)) = T :- {s_mod}
    typeOfPath(s, p) == MOD(s_mod),
    typeOfRef(s_mod, m) == T.
             
  proj(MOD(s_mod), x) = T :- {p d}
    typeOfVar(s_mod, x) == T.
    
rules // qualified names 
  
  typeOfExp(s, PExp(Path(p,x))) = T :- {s_mod}
  	proj(typeOfPath(s, p), x) == T.
  
  typeOfType(s, PType(Path(p,x))) = T :- {s_mod} 
  	typeOfPath(s, p) == MOD(s_mod),
  	typeOfTypeRef(s_mod, x) == T.
  
rules // extend remote

//  declOk(s, ExtendRemote(p, x, e)) :- {s_mod T}
//    typeOfExp(s, p) == MOD(s_mod),
//    typeOfExp(s, e) == T,
//    declareVar(s_mod, x, T). // no permission to extend

signature    
  namespaces
    Mod : string
  name-resolution
    resolve Mod 
      filter P* (R* | I*) 
      min $ < I, $ < P, I < P, R < P 
      
rules 
  scopeOfParent : scope -> scope 
  
  scopeOfParent(s1) = s2 :- {p t}
    query () filter P+ min $ < P in s1 |-> [(_, s2) | _]. 
          
rules // module names
 
  declareMod      : scope * string * TYPE
  typeOfModRef    : scope * string -> TYPE
  typeOfModRefRaw : scope * string -> list((path * (occurrence * TYPE)))
    
  declareMod(s, x, T) :-   
    s -> Mod{x} with typeOfDecl T, 
    typeOfDecl of Mod{x} in s |-> [(_, (_, T))] 
             | error $[Duplicate definition of module [x]],
             // declaration is distinct
    @x.type := T.
  
  typeOfModRef(s, x) = T :- {x'}
    typeOfDecl of Mod{x} in s |-> [(_, (Mod{x'}, T))|_] 
             | error $[Module [x] not defined],
               // permissive lookup to cope with double declaration 
    @x.ref := x',
    @x.type := T.
    
  typeOfModRefRaw(s, x) = p :-
    typeOfDecl of Mod{x} in s |-> p.
    
rules

  typeOfRef : scope * string -> TYPE
  typeOfRefDisamb : scope * string * list((path * (occurrence * TYPE))) -> TYPE
  
 
  typeOfRef(s, x) = typeOfRefDisamb(s, x, typeOfModRefRaw(s, x)).
    
  typeOfRefDisamb(s, x, []) = typeOfVar(s, x).
  
  typeOfRefDisamb(s, x, [(_, (Mod{x'}, T)) | _]) = T :-
    @x.ref := x',
    @x.type := T.
    