module statics/variable

imports statics/base
imports signatures/variable-sig
    
rules
    
  typeOfExp(s, Var(x)) = typeOfVar(s, x).
    
rules

  declOk(s, Def(bind)) :- 
    bindOk(s, s, bind).
    
rules

  bindOk(s_bnd, s_ctx, Bind(x, e)) :- {T}
    typeOfExp(s_ctx, e) == T,
    declareVar(s_bnd, x, T).
    
  bindOk(s_bnd, s_ctx, BindT(x, t, e)) :- {T1 T2}
    typeOfType(s_ctx, t) == T1,
    declareVar(s_bnd, x, T1),
    typeOfExp(s_ctx, e) == T2,
    subtype(T2, T1) 
    | error $[type of expression [T2] does not match expected type [T1]].

 
rules // variable binding 
 
  declareVar   : scope * string * TYPE
  typeOfVar    : scope * string -> TYPE
    
  declareVar(s, x, T) :-   
    s -> Var{x} with typeOfDecl T, 
    typeOfDecl of Var{x} in s |-> [(_, (_, T))] 
             | error $[Duplicate definition of variable [x]],
    @x.type := T.
               // declaration is distinct
  
  typeOfVar(s, x) = T :- {x'}
    typeOfDecl of Var{x} in s |-> [(_, (Var{x'}, T))|_] 
             | error $[Variable [x] not defined],
               // permissive lookup to cope with double declaration 
    @x.ref := x',
    @x.type := T.
  
//  typeOfVarRaw : scope * string -> list((path * (occurrence * TYPE)))
//  typeOfVarRaw(s, x) = p :-
//    typeOfDecl of Var{x} in s |-> p.
    
signature    
  namespaces
    Var : string
  name-resolution
    resolve Var 
      filter P* (R* | I*) 
      min $ < I, $ < P, I < P, R < P 
      

    