module statics/signature

signature
  sorts ID = string
  sorts INT = string 
  sorts STRING = string
  
  sorts Program constructors
    Program  : list(Decl) -> Program
    
  sorts TYPE
  sorts Exp 
    
  sorts Decl constructors
    Exp      : Exp -> Decl
    TypeDef  : ID * Type -> Decl
    
  constructors // modules
    MOD      : scope -> TYPE
    Mod      : ID -> Exp
    Module   : ID * list(Decl) -> Decl
    Import   : list(ID) -> Decl
    
  sorts Type constructors
    TypeRef  : ID -> Type
    
  sorts Bind constructors
    Def      : Bind -> Decl
    Bind     : ID * Exp -> Bind
    TBind    : ID * Type * Exp -> Bind
  
  sorts FBind constructors
    FBind    : ID * Exp -> FBind
    
  constructors // variables
    Var      : ID -> Exp
    Let      : list(Bind) * Exp -> Exp
    LetPar   : list(Bind) * Exp -> Exp
    LetRec   : list(Bind) * Exp -> Exp
    
  constructors // booleans
    BoolT    : Type
    BOOL     : TYPE
    True     : Exp
    False    : Exp
    Not      : Exp -> Exp
    If       : Exp * Exp * Exp -> Exp

  sorts FDecl // functions
  constructors 
    FunT     : Type * Type -> Type
    FUN      : TYPE * TYPE -> TYPE
    FDecl    : ID * Type -> FDecl
    Fun      : ID * Type * Exp -> Exp
    FunUT    : ID * Exp -> Exp
    App      : Exp * Exp -> Exp
    
  constructors // strings
    StringT  : Type
    STRING   : TYPE
    Str      : STRING -> Exp
    
  constructors // arithmetic
    IntT     : Type
    INT      : TYPE
    Int      : INT -> Exp
    Add      : Exp * Exp -> Exp
    Sub      : Exp * Exp -> Exp
    Mul      : Exp * Exp -> Exp
    Eq       : Exp * Exp -> Exp
    
  constructors // records
    RecT     : list(FDecl) -> Type
    REC      : scope -> TYPE
    Record   : ID * list(FDecl) -> Decl
    New      : ID * list(FBind) -> Exp
    With     : Exp * Exp -> Exp
    Proj     : Exp * ID -> Exp
    
//  constructors // placeholders
//    Exp-Plhdr : Exp
    
    
  namespaces
    Var  : string
    Mod  : string
    Type : string
    
  name-resolution
    labels P I R
             
    resolve Type filter P* (R* | I*) min $ < I, $ < P, I < P, R < P
    resolve Var filter P* (R* | I*) min $ < I, $ < P, I < P, R < P
    resolve Mod filter P P* I* min $ < I, $ < P, I < P, R < P     
              
  relations 
    typeOfDecl : occurrence -> TYPE 
    
    
rules // variable binding 

  declareVar : scope * string * TYPE
  declareVarRaw : scope * string * TYPE
  lookupVar : scope * string -> TYPE
    
  declareVar(s, x, T) :-   
    s -> Var{x} with typeOfDecl T, 
    typeOfDecl of Var{x} in s |-> [(_, (_, T))] | error $[Duplicate definition].
    // declaration is distinct

  declareVarRaw(s, x, T) :-   
    s -> Var{x} with typeOfDecl T,
    typeOfDecl of Var{x} in s |-> [(_, (_, T))]. 
    // declaration is distinct
  
  lookupVar(s, x) = T :- {d}
    typeOfDecl of Var{x} in s |-> [(_, (d, T))|_] | error $[Variable not defined],
    // permissive lookup to cope with double declaration 
    @x.ref := d.
    
rules // type binding 

  declareType : scope * string * TYPE
  declareTypeRaw : scope * string * TYPE
  lookupType : scope * string -> TYPE
    
  declareType(s, x, T) :-   
    s -> Type{x} with typeOfDecl T, 
    typeOfDecl of Type{x} in s |-> [(_, (_, T))] | error $[Duplicate definition].
    // declaration is distinct

  declareTypeRaw(s, x, T) :-   
    s -> Type{x} with typeOfDecl T,
    typeOfDecl of Type{x} in s |-> [(_, (_, T))]. 
    // declaration is distinct
  
  lookupType(s, x) = T :-
    typeOfDecl of Type{x} in s |-> [(_, (_, T))|_] | error $[Type not defined]. 
    // permissive lookup to cope with double declaration 
    
    
rules // module binding 

  declareMod : scope * string * TYPE
  declareModRaw : scope * string * TYPE
  lookupMod : scope * string -> TYPE
    
  declareMod(s, x, T) :-   
    s -> Mod{x} with typeOfDecl T, 
    typeOfDecl of Mod{x} in s |-> [(_, (_, T))] | error $[Duplicate definition of module [x]].
    // declaration is distinct

  declareModRaw(s, x, T) :-   
    s -> Mod{x} with typeOfDecl T,
    typeOfDecl of Mod{x} in s |-> [(_, (_, T))]. 
    // declaration is distinct
  
  lookupMod(s, x) = T :-
    typeOfDecl of Mod{x} in s |-> [(_, (_, T))|_] | error $[Modiable not defined]. 
    // permissive lookup to cope with double declaration 